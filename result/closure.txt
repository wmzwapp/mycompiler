closure 0:
S'' ->.S' ,# 
S' ->.AS ,# 
A ->.intIDB ,int void # 
A ->.voidIDC ,int void # 
closure 1:
S' ->A.S ,# 
S ->.S' ,# 
S ->._ ,# 
S' ->.AS ,# 
A ->.intIDB ,int void # 
A ->.voidIDC ,int void # 
closure 2:
S'' ->S'. ,# 
closure 3:
A ->int.IDB ,int void # 
closure 4:
A ->void.IDC ,int void # 
closure 5:
S' ->AS. ,# 
closure 6:
S ->S'. ,# 
closure 7:
A ->intID.B ,int void # 
B ->.D ,int void # 
B ->.C ,int void # 
C ->.(E)F ,int void # 
D ->.; ,int void # 
closure 8:
A ->voidID.C ,int void # 
C ->.(E)F ,int void # 
closure 9:
A ->intIDB. ,int void # 
closure 10:
B ->C. ,int void # 
closure 11:
B ->D. ,int void # 
closure 12:
D ->;. ,int void # 
closure 13:
C ->(.E)F ,int void # 
E ->.G ,) 
E ->.void ,) 
G ->.HG' ,) 
H ->.intID ,) , 
closure 14:
A ->voidIDC. ,int void # 
closure 15:
C ->(E.)F ,int void # 
closure 16:
E ->G. ,) 
closure 17:
G ->H.G' ,) 
G' ->.,G ,) 
G' ->._ ,) 
closure 18:
H ->int.ID ,, ) 
closure 19:
E ->void. ,) 
closure 20:
C ->(E).F ,int void # 
F ->.{IJ} ,int void # 
closure 21:
G ->HG'. ,) 
closure 22:
G' ->,.G ,) 
G ->.HG' ,) 
H ->.intID ,) , 
closure 23:
H ->intID. ,) , 
closure 24:
C ->(E)F. ,int void # 
closure 25:
F ->{.IJ} ,int void # 
I ->.K;I ,while ID if return 
I ->._ ,while ID if return 
K ->.intID ,; 
closure 26:
G' ->,G. ,) 
closure 27:
F ->{I.J} ,int void # 
J ->.LJ' ,} 
L ->.M ,ID if return while } 
L ->.N ,ID if return while } 
L ->.O ,ID if return while } 
L ->.P ,ID if return while } 
P ->.ID=Q; ,if return while } ID 
O ->.returnO'; ,if return while } ID 
N ->.while(Q)F ,if return while } ID 
M ->.if(Q)FM' ,if return while } ID 
closure 28:
I ->K.;I ,while ID if return 
closure 29:
K ->int.ID ,; 
closure 30:
F ->{IJ.} ,int void # 
closure 31:
J ->L.J' ,} 
J' ->.J ,} 
J' ->._ ,} 
J ->.LJ' ,} 
L ->.M ,ID if return while } 
L ->.N ,ID if return while } 
L ->.O ,ID if return while } 
L ->.P ,ID if return while } 
P ->.ID=Q; ,if return while } ID 
O ->.returnO'; ,if return while } ID 
N ->.while(Q)F ,if return while } ID 
M ->.if(Q)FM' ,if return while } ID 
closure 32:
L ->M. ,if return while } ID 
closure 33:
L ->N. ,if return while } ID 
closure 34:
L ->O. ,if return while } ID 
closure 35:
L ->P. ,if return while } ID 
closure 36:
M ->if.(Q)FM' ,if return while } ID 
closure 37:
N ->while.(Q)F ,if return while } ID 
closure 38:
O ->return.O'; ,if return while } ID 
O' ->.Q ,; 
O' ->._ ,; 
Q ->.RQ' ,; 
R ->.UR' ,== > ; >= != <= < 
U ->.VU' ,+ == < > ; >= != <= - 
V ->.NUM ,+ == / < > ; * >= != <= - 
V ->.(Q) ,+ == / < > ; * >= != <= - 
V ->.IDW ,+ == / < > ; * >= != <= - 
closure 39:
P ->ID.=Q; ,if return while } ID 
closure 40:
I ->K;.I ,while ID if return 
I ->.K;I ,while ID if return 
I ->._ ,while ID if return 
K ->.intID ,; 
closure 41:
K ->intID. ,; 
closure 42:
F ->{IJ}. ,int void # 
closure 43:
J' ->J. ,} 
closure 44:
J ->LJ'. ,} 
closure 45:
M ->if(.Q)FM' ,if return while } ID 
Q ->.RQ' ,) 
R ->.UR' ,== > ) >= != <= < 
U ->.VU' ,+ == ) < > >= != <= - 
V ->.NUM ,+ == ) / < > * >= != <= - 
V ->.(Q) ,+ == ) / < > * >= != <= - 
V ->.IDW ,+ == ) / < > * >= != <= - 
closure 46:
N ->while(.Q)F ,if return while } ID 
Q ->.RQ' ,) 
R ->.UR' ,== > ) >= != <= < 
U ->.VU' ,+ == ) < > >= != <= - 
V ->.NUM ,+ == ) / < > * >= != <= - 
V ->.(Q) ,+ == ) / < > * >= != <= - 
V ->.IDW ,+ == ) / < > * >= != <= - 
closure 47:
O ->returnO'.; ,if return while } ID 
closure 48:
O' ->Q. ,; 
closure 49:
Q ->R.Q' ,; 
Q' ->.TQ ,; 
Q' ->._ ,; 
T ->.< ,ID ( NUM 
T ->.<= ,ID ( NUM 
T ->.> ,ID ( NUM 
T ->.>= ,ID ( NUM 
T ->.== ,ID ( NUM 
T ->.!= ,ID ( NUM 
closure 50:
R ->U.R' ,== < > ; != >= <= 
R' ->.+R ,== < > ; != >= <= 
R' ->.-R ,== < > ; != >= <= 
R' ->._ ,== < > ; != >= <= 
closure 51:
U ->V.U' ,+ == < > ; >= != <= - 
U' ->.*U ,+ == < > ; >= != <= - 
U' ->./U ,+ == < > ; >= != <= - 
U' ->._ ,+ == < > ; >= != <= - 
closure 52:
V ->ID.W ,+ == / < > ; * >= != <= - 
W ->.X ,+ == / < > ; * >= != <= - 
W ->._ ,+ == / < > ; * >= != <= - 
X ->.(Y) ,+ == / < > ; * >= != <= - 
closure 53:
V ->NUM. ,+ == / < > ; * >= != <= - 
closure 54:
V ->(.Q) ,+ == / < > ; * >= != <= - 
Q ->.RQ' ,) 
R ->.UR' ,== > ) >= != <= < 
U ->.VU' ,+ == ) < > >= != <= - 
V ->.NUM ,+ == ) / < > * >= != <= - 
V ->.(Q) ,+ == ) / < > * >= != <= - 
V ->.IDW ,+ == ) / < > * >= != <= - 
closure 55:
P ->ID=.Q; ,if return while } ID 
Q ->.RQ' ,; 
R ->.UR' ,== > ; >= != <= < 
U ->.VU' ,+ == < > ; >= != <= - 
V ->.NUM ,+ == / < > ; * >= != <= - 
V ->.(Q) ,+ == / < > ; * >= != <= - 
V ->.IDW ,+ == / < > ; * >= != <= - 
closure 56:
I ->K;I. ,while ID if return 
closure 57:
M ->if(Q.)FM' ,if return while } ID 
closure 58:
Q ->R.Q' ,) 
Q' ->.TQ ,) 
Q' ->._ ,) 
T ->.< ,ID ( NUM 
T ->.<= ,ID ( NUM 
T ->.> ,ID ( NUM 
T ->.>= ,ID ( NUM 
T ->.== ,ID ( NUM 
T ->.!= ,ID ( NUM 
closure 59:
R ->U.R' ,== ) < > != >= <= 
R' ->.+R ,== ) < > != >= <= 
R' ->.-R ,== ) < > != >= <= 
R' ->._ ,== ) < > != >= <= 
closure 60:
U ->V.U' ,+ == ) < > >= != <= - 
U' ->.*U ,+ == ) < > >= != <= - 
U' ->./U ,+ == ) < > >= != <= - 
U' ->._ ,+ == ) < > >= != <= - 
closure 61:
V ->ID.W ,+ == ) / < > * >= != <= - 
W ->.X ,+ == ) / < > * >= != <= - 
W ->._ ,+ == ) / < > * >= != <= - 
X ->.(Y) ,+ == ) / < > * >= != <= - 
closure 62:
V ->NUM. ,+ == ) / < > * >= != <= - 
closure 63:
V ->(.Q) ,+ == ) / < > * >= != <= - 
Q ->.RQ' ,) 
R ->.UR' ,== > ) >= != <= < 
U ->.VU' ,+ == ) < > >= != <= - 
V ->.NUM ,+ == ) / < > * >= != <= - 
V ->.(Q) ,+ == ) / < > * >= != <= - 
V ->.IDW ,+ == ) / < > * >= != <= - 
closure 64:
N ->while(Q.)F ,if return while } ID 
closure 65:
O ->returnO';. ,if return while } ID 
closure 66:
Q ->RQ'. ,; 
closure 67:
Q' ->T.Q ,; 
Q ->.RQ' ,; 
R ->.UR' ,== > ; >= != <= < 
U ->.VU' ,+ == < > ; >= != <= - 
V ->.NUM ,+ == / < > ; * >= != <= - 
V ->.(Q) ,+ == / < > ; * >= != <= - 
V ->.IDW ,+ == / < > ; * >= != <= - 
closure 68:
T ->==. ,ID ( NUM 
closure 69:
T ->!=. ,ID ( NUM 
closure 70:
T -><. ,ID ( NUM 
closure 71:
T -><=. ,ID ( NUM 
closure 72:
T ->>. ,ID ( NUM 
closure 73:
T ->>=. ,ID ( NUM 
closure 74:
R ->UR'. ,== < > ; != >= <= 
closure 75:
R' ->+.R ,== < > ; != >= <= 
R ->.UR' ,== < > ; != >= <= 
U ->.VU' ,+ == < > ; != >= <= - 
V ->.NUM ,+ == / < > ; * != >= <= - 
V ->.(Q) ,+ == / < > ; * != >= <= - 
V ->.IDW ,+ == / < > ; * != >= <= - 
closure 76:
R' ->-.R ,== < > ; != >= <= 
R ->.UR' ,== < > ; != >= <= 
U ->.VU' ,+ == < > ; != >= <= - 
V ->.NUM ,+ == / < > ; * != >= <= - 
V ->.(Q) ,+ == / < > ; * != >= <= - 
V ->.IDW ,+ == / < > ; * != >= <= - 
closure 77:
U ->VU'. ,+ == < > ; >= != <= - 
closure 78:
U' ->*.U ,+ == < > ; >= != <= - 
U ->.VU' ,+ == < > ; >= != <= - 
V ->.NUM ,+ == / < > ; * >= != <= - 
V ->.(Q) ,+ == / < > ; * >= != <= - 
V ->.IDW ,+ == / < > ; * >= != <= - 
closure 79:
U' ->/.U ,+ == < > ; >= != <= - 
U ->.VU' ,+ == < > ; >= != <= - 
V ->.NUM ,+ == / < > ; * >= != <= - 
V ->.(Q) ,+ == / < > ; * >= != <= - 
V ->.IDW ,+ == / < > ; * >= != <= - 
closure 80:
V ->IDW. ,+ == / < > ; * >= != <= - 
closure 81:
W ->X. ,+ == / < > ; * >= != <= - 
closure 82:
X ->(.Y) ,+ == / < > ; * >= != <= - 
Y ->.Z ,) 
Y ->._ ,) 
Z ->.QZ' ,) 
Q ->.RQ' ,, 
R ->.UR' ,== > >= != , <= < 
U ->.VU' ,+ == < > >= != <= - , 
V ->.NUM ,+ == / < > * >= != <= - , 
V ->.(Q) ,+ == / < > * >= != <= - , 
V ->.IDW ,+ == / < > * >= != <= - , 
closure 83:
V ->(Q.) ,+ == / < > ; * >= != <= - 
closure 84:
P ->ID=Q.; ,if return while } ID 
closure 85:
M ->if(Q).FM' ,if return while } ID 
F ->.{IJ} ,ID if else return while } 
closure 86:
Q ->RQ'. ,) 
closure 87:
Q' ->T.Q ,) 
Q ->.RQ' ,) 
R ->.UR' ,== > ) >= != <= < 
U ->.VU' ,+ == ) < > >= != <= - 
V ->.NUM ,+ == ) / < > * >= != <= - 
V ->.(Q) ,+ == ) / < > * >= != <= - 
V ->.IDW ,+ == ) / < > * >= != <= - 
closure 88:
R ->UR'. ,== ) < > != >= <= 
closure 89:
R' ->+.R ,== ) < > != >= <= 
R ->.UR' ,== ) < > != >= <= 
U ->.VU' ,+ == ) < > != >= <= - 
V ->.NUM ,+ == ) / < > * != >= <= - 
V ->.(Q) ,+ == ) / < > * != >= <= - 
V ->.IDW ,+ == ) / < > * != >= <= - 
closure 90:
R' ->-.R ,== ) < > != >= <= 
R ->.UR' ,== ) < > != >= <= 
U ->.VU' ,+ == ) < > != >= <= - 
V ->.NUM ,+ == ) / < > * != >= <= - 
V ->.(Q) ,+ == ) / < > * != >= <= - 
V ->.IDW ,+ == ) / < > * != >= <= - 
closure 91:
U ->VU'. ,+ == ) < > >= != <= - 
closure 92:
U' ->*.U ,+ == ) < > >= != <= - 
U ->.VU' ,+ == ) < > >= != <= - 
V ->.NUM ,+ == ) / < > * >= != <= - 
V ->.(Q) ,+ == ) / < > * >= != <= - 
V ->.IDW ,+ == ) / < > * >= != <= - 
closure 93:
U' ->/.U ,+ == ) < > >= != <= - 
U ->.VU' ,+ == ) < > >= != <= - 
V ->.NUM ,+ == ) / < > * >= != <= - 
V ->.(Q) ,+ == ) / < > * >= != <= - 
V ->.IDW ,+ == ) / < > * >= != <= - 
closure 94:
V ->IDW. ,+ == ) / < > * >= != <= - 
closure 95:
W ->X. ,+ == ) / < > * >= != <= - 
closure 96:
X ->(.Y) ,+ == ) / < > * >= != <= - 
Y ->.Z ,) 
Y ->._ ,) 
Z ->.QZ' ,) 
Q ->.RQ' ,, 
R ->.UR' ,== > >= != , <= < 
U ->.VU' ,+ == < > >= != <= - , 
V ->.NUM ,+ == / < > * >= != <= - , 
V ->.(Q) ,+ == / < > * >= != <= - , 
V ->.IDW ,+ == / < > * >= != <= - , 
closure 97:
V ->(Q.) ,+ == ) / < > * >= != <= - 
closure 98:
N ->while(Q).F ,if return while } ID 
F ->.{IJ} ,if return while } ID 
closure 99:
Q' ->TQ. ,; 
closure 100:
R' ->+R. ,== < > ; != >= <= 
closure 101:
R' ->-R. ,== < > ; != >= <= 
closure 102:
U' ->*U. ,+ == < > ; >= != <= - 
closure 103:
U' ->/U. ,+ == < > ; >= != <= - 
closure 104:
Z ->Q.Z' ,) 
Z' ->.,Z ,) 
Z' ->. ,) 
closure 105:
Q ->R.Q' ,, 
Q' ->.TQ ,, 
Q' ->._ ,, 
T ->.< ,ID ( NUM 
T ->.<= ,ID ( NUM 
T ->.> ,ID ( NUM 
T ->.>= ,ID ( NUM 
T ->.== ,ID ( NUM 
T ->.!= ,ID ( NUM 
closure 106:
R ->U.R' ,== < > != >= <= , 
R' ->.+R ,== < > >= != <= , 
R' ->.-R ,== < > >= != <= , 
R' ->._ ,== < > >= != <= , 
closure 107:
U ->V.U' ,+ == < > >= != <= - , 
U' ->.*U ,+ == < > >= != <= - , 
U' ->./U ,+ == < > >= != <= - , 
U' ->._ ,+ == < > >= != <= - , 
closure 108:
X ->(Y.) ,+ == / < > ; * >= != <= - 
closure 109:
Y ->Z. ,) 
closure 110:
V ->ID.W ,+ == / < > * >= != <= - , 
W ->.X ,+ == / < > * >= != <= - , 
W ->._ ,+ == / < > * >= != <= - , 
X ->.(Y) ,+ == / < > * >= != <= - , 
closure 111:
V ->NUM. ,+ == / < > * >= != <= - , 
closure 112:
V ->(.Q) ,+ == / < > * >= != <= - , 
Q ->.RQ' ,) 
R ->.UR' ,== > ) >= != <= < 
U ->.VU' ,+ == ) < > >= != <= - 
V ->.NUM ,+ == ) / < > * >= != <= - 
V ->.(Q) ,+ == ) / < > * >= != <= - 
V ->.IDW ,+ == ) / < > * >= != <= - 
closure 113:
V ->(Q). ,+ == / < > ; * >= != <= - 
closure 114:
P ->ID=Q;. ,if return while } ID 
closure 115:
M ->if(Q)F.M' ,if return while } ID 
M' ->.elseF ,if return while } ID 
M' ->._ ,if return while } ID 
closure 116:
F ->{.IJ} ,else if return while } ID 
I ->.K;I ,while ID if return 
I ->._ ,while ID if return 
K ->.intID ,; 
closure 117:
Q' ->TQ. ,) 
closure 118:
R' ->+R. ,== ) < > != >= <= 
closure 119:
R' ->-R. ,== ) < > != >= <= 
closure 120:
U' ->*U. ,+ == ) < > >= != <= - 
closure 121:
U' ->/U. ,+ == ) < > >= != <= - 
closure 122:
X ->(Y.) ,+ == ) / < > * >= != <= - 
closure 123:
V ->(Q). ,+ == ) / < > * >= != <= - 
closure 124:
N ->while(Q)F. ,if return while } ID 
closure 125:
F ->{.IJ} ,if return while } ID 
I ->.K;I ,while ID if return 
I ->._ ,while ID if return 
K ->.intID ,; 
closure 126:
Z ->QZ'. ,) 
closure 127:
Z' ->,.Z ,) 
Z ->.QZ' ,) 
Q ->.RQ' ,, 
R ->.UR' ,== > >= != , <= < 
U ->.VU' ,+ == < > >= != <= - , 
V ->.NUM ,+ == / < > * >= != <= - , 
V ->.(Q) ,+ == / < > * >= != <= - , 
V ->.IDW ,+ == / < > * >= != <= - , 
closure 128:
Q ->RQ'. ,, 
closure 129:
Q' ->T.Q ,, 
Q ->.RQ' ,, 
R ->.UR' ,== > >= != , <= < 
U ->.VU' ,+ == < > >= != <= - , 
V ->.NUM ,+ == / < > * >= != <= - , 
V ->.(Q) ,+ == / < > * >= != <= - , 
V ->.IDW ,+ == / < > * >= != <= - , 
closure 130:
R ->UR'. ,== < > >= != <= , 
closure 131:
R' ->+.R ,== < > != >= <= , 
R ->.UR' ,== < > >= != <= , 
U ->.VU' ,+ == < > >= != <= - , 
V ->.NUM ,+ == / < > * >= != <= - , 
V ->.(Q) ,+ == / < > * >= != <= - , 
V ->.IDW ,+ == / < > * >= != <= - , 
closure 132:
R' ->-.R ,== < > != >= <= , 
R ->.UR' ,== < > >= != <= , 
U ->.VU' ,+ == < > >= != <= - , 
V ->.NUM ,+ == / < > * >= != <= - , 
V ->.(Q) ,+ == / < > * >= != <= - , 
V ->.IDW ,+ == / < > * >= != <= - , 
closure 133:
U ->VU'. ,+ == < > >= != <= - , 
closure 134:
U' ->*.U ,+ == < > >= != <= - , 
U ->.VU' ,+ == < > >= != <= - , 
V ->.NUM ,+ == / < > * >= != <= - , 
V ->.(Q) ,+ == / < > * >= != <= - , 
V ->.IDW ,+ == / < > * >= != <= - , 
closure 135:
U' ->/.U ,+ == < > >= != <= - , 
U ->.VU' ,+ == < > >= != <= - , 
V ->.NUM ,+ == / < > * >= != <= - , 
V ->.(Q) ,+ == / < > * >= != <= - , 
V ->.IDW ,+ == / < > * >= != <= - , 
closure 136:
X ->(Y). ,+ == / < > ; * >= != <= - 
closure 137:
V ->IDW. ,+ == / < > * >= != <= - , 
closure 138:
W ->X. ,+ == / < > * >= != <= - , 
closure 139:
X ->(.Y) ,+ == / < > * >= != <= - , 
Y ->.Z ,) 
Y ->._ ,) 
Z ->.QZ' ,) 
Q ->.RQ' ,, 
R ->.UR' ,== > >= != , <= < 
U ->.VU' ,+ == < > >= != <= - , 
V ->.NUM ,+ == / < > * >= != <= - , 
V ->.(Q) ,+ == / < > * >= != <= - , 
V ->.IDW ,+ == / < > * >= != <= - , 
closure 140:
V ->(Q.) ,+ == / < > * >= != <= - , 
closure 141:
M ->if(Q)FM'. ,if return while } ID 
closure 142:
M' ->else.F ,if return while } ID 
F ->.{IJ} ,if return while } ID 
closure 143:
F ->{I.J} ,if else return while } ID 
J ->.LJ' ,} 
L ->.M ,ID if return while } 
L ->.N ,ID if return while } 
L ->.O ,ID if return while } 
L ->.P ,ID if return while } 
P ->.ID=Q; ,if return while } ID 
O ->.returnO'; ,if return while } ID 
N ->.while(Q)F ,if return while } ID 
M ->.if(Q)FM' ,if return while } ID 
closure 144:
X ->(Y). ,+ == ) / < > * >= != <= - 
closure 145:
F ->{I.J} ,if return while } ID 
J ->.LJ' ,} 
L ->.M ,ID if return while } 
L ->.N ,ID if return while } 
L ->.O ,ID if return while } 
L ->.P ,ID if return while } 
P ->.ID=Q; ,if return while } ID 
O ->.returnO'; ,if return while } ID 
N ->.while(Q)F ,if return while } ID 
M ->.if(Q)FM' ,if return while } ID 
closure 146:
Z' ->,Z. ,) 
closure 147:
Q' ->TQ. ,, 
closure 148:
R' ->+R. ,== < > >= != <= , 
closure 149:
R' ->-R. ,== < > >= != <= , 
closure 150:
U' ->*U. ,+ == < > >= != <= - , 
closure 151:
U' ->/U. ,+ == < > >= != <= - , 
closure 152:
X ->(Y.) ,+ == / < > * >= != <= - , 
closure 153:
V ->(Q). ,+ == / < > * >= != <= - , 
closure 154:
M' ->elseF. ,if return while } ID 
closure 155:
F ->{IJ.} ,else if return while } ID 
closure 156:
F ->{IJ.} ,if return while } ID 
closure 157:
X ->(Y). ,+ == / < > * >= != <= - , 
closure 158:
F ->{IJ}. ,if else return while } ID 
closure 159:
F ->{IJ}. ,if return while } ID 
